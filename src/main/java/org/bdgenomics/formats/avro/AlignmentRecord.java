/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package org.bdgenomics.formats.avro;  
@SuppressWarnings("all")
@org.apache.avro.specific.AvroGenerated
public class AlignmentRecord extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"AlignmentRecord\",\"namespace\":\"org.bdgenomics.formats.avro\",\"fields\":[{\"name\":\"readNum\",\"type\":[\"int\",\"null\"],\"doc\":\"Read number within the array of fragment reads.\",\"default\":0},{\"name\":\"contig\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"Contig\",\"doc\":\"Record for describing a reference assembly. Not used for storing the contents\\n of said assembly.\\n\\n @see NucleotideContigFragment\",\"fields\":[{\"name\":\"contigName\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this contig in the assembly (e.g., \\\"chr1\\\").\",\"default\":null},{\"name\":\"contigLength\",\"type\":[\"null\",\"long\"],\"doc\":\"The length of this contig.\",\"default\":null},{\"name\":\"contigMD5\",\"type\":[\"null\",\"string\"],\"doc\":\"The MD5 checksum of the assembly for this contig.\",\"default\":null},{\"name\":\"referenceURL\",\"type\":[\"null\",\"string\"],\"doc\":\"The URL at which this reference assembly can be found.\",\"default\":null},{\"name\":\"assembly\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this assembly (e.g., \\\"hg19\\\").\",\"default\":null},{\"name\":\"species\",\"type\":[\"null\",\"string\"],\"doc\":\"The species that this assembly is for.\",\"default\":null}]}],\"doc\":\"The reference sequence details for the reference chromosome that\\n   this read is aligned to. If the read is unaligned, this field should\\n   be null.\",\"default\":null},{\"name\":\"start\",\"type\":[\"null\",\"long\"],\"doc\":\"0 based reference position for the start of this read's alignment.\\n   Should be null if the read is unaligned.\",\"default\":null},{\"name\":\"oldPosition\",\"type\":[\"null\",\"long\"],\"doc\":\"0 based reference position where this read used to start before\\n   local realignment.\\n   Stores the same data as the OP field in the SAM format.\",\"default\":null},{\"name\":\"end\",\"type\":[\"null\",\"long\"],\"doc\":\"0 based reference position for the end of this read's alignment.\\n   Should be null if the read is unaligned.\",\"default\":null},{\"name\":\"mapq\",\"type\":[\"null\",\"int\"],\"doc\":\"The global mapping quality of this read.\",\"default\":null},{\"name\":\"readName\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this read. This should be unique within the read group\\n   that this read is from, and can be used to identify other reads that\\n   are derived from a single fragment.\",\"default\":null},{\"name\":\"sequence\",\"type\":[\"null\",\"string\"],\"doc\":\"The bases in this alignment. If the read has been hard clipped, this may\\n   not represent all the bases in the original read.\",\"default\":null},{\"name\":\"qual\",\"type\":[\"null\",\"string\"],\"doc\":\"The per-base quality scores in this alignment. If the read has been hard\\n   clipped, this may not represent all the bases in the original read.\\n   Additionally, if the error scores have been recalibrated, this field\\n   will not contain the original base quality scores.\\n\\n   @see origQual\",\"default\":null},{\"name\":\"cigar\",\"type\":[\"null\",\"string\"],\"doc\":\"The Compact Ideosyncratic Gapped Alignment Report (CIGAR) string that\\n   describes the local alignment of this read. Contains {length, operator}\\n   pairs for all contiguous alignment operations. The operators include:\\n\\n   * M, ALIGNMENT_MATCH: An alignment match indicates that a sequence can be\\n     aligned to the reference without evidence of an INDEL. Unlike the\\n     SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the ALIGNMENT_MATCH\\n     operator does not indicate whether the reference and read sequences are an\\n     exact match.\\n   * I, INSERT: The insert operator indicates that the read contains evidence of\\n     bases being inserted into the reference.\\n   * D, DELETE: The delete operator indicates that the read contains evidence of\\n     bases being deleted from the reference.\\n   * N, SKIP: The skip operator indicates that this read skips a long segment of\\n     the reference, but the bases have not been deleted. This operator is\\n     commonly used when working with RNA-seq data, where reads may skip long\\n     segments of the reference between exons.\\n   * S, CLIP_SOFT: The soft clip operator indicates that bases at the start/end\\n     of a read have not been considered during alignment. This may occur if the\\n     majority of a read maps, except for low quality bases at the start/end of\\n     a read. Bases that are soft clipped will still be stored in the read.\\n   * H, CLIP_HARD: The hard clip operator indicates that bases at the start/end of\\n     a read have been omitted from this alignment. This may occur if this linear\\n     alignment is part of a chimeric alignment, or if the read has been trimmed\\n     (e.g., during error correction, or to trim poly-A tails for RNA-seq).\\n   * P, PAD: The pad operator indicates that there is padding in an alignment.\\n   * =, SEQUENCE_MATCH: This operator indicates that this portion of the aligned\\n     sequence exactly matches the reference (e.g., all bases are equal to the\\n     reference bases).\\n   * X, SEQUENCE_MISMATCH: This operator indicates that this portion of the\\n     aligned sequence is an alignment match to the reference, but a sequence\\n     mismatch (e.g., the bases are not equal to the reference). This can\\n     indicate a SNP or a read error.\",\"default\":null},{\"name\":\"oldCigar\",\"type\":[\"null\",\"string\"],\"doc\":\"Stores the CIGAR string present before local indel realignment.\\n   Stores the same data as the OC field in the SAM format.\\n\\n   @see cigar\",\"default\":null},{\"name\":\"basesTrimmedFromStart\",\"type\":[\"int\",\"null\"],\"doc\":\"The number of bases in this read/alignment that have been trimmed from the\\n   start of the read. By default, this is equal to 0. If the value is non-zero,\\n   that means that the start of the read has been hard-clipped.\\n\\n   @see cigar\",\"default\":0},{\"name\":\"basesTrimmedFromEnd\",\"type\":[\"int\",\"null\"],\"doc\":\"The number of bases in this read/alignment that have been trimmed from the\\n   end of the read. By default, this is equal to 0. If the value is non-zero,\\n   that means that the end of the read has been hard-clipped.\\n\\n   @see cigar\",\"default\":0},{\"name\":\"readPaired\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"properPair\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"readMapped\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"mateMapped\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"firstOfPair\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"secondOfPair\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"failedVendorQualityChecks\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"duplicateRead\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"readNegativeStrand\",\"type\":[\"boolean\",\"null\"],\"doc\":\"True if this alignment is mapped as a reverse compliment. This field\\n   defaults to false.\",\"default\":false},{\"name\":\"mateNegativeStrand\",\"type\":[\"boolean\",\"null\"],\"doc\":\"True if the mate pair of this alignment is mapped as a reverse compliment.\\n   This field defaults to false.\",\"default\":false},{\"name\":\"primaryAlignment\",\"type\":[\"boolean\",\"null\"],\"doc\":\"This field is true if this alignment is either the best linear alignment,\\n   or the first linear alignment in a chimeric alignment. Defaults to false.\\n\\n   @see secondaryAlignment\\n   @see supplementaryAlignment\",\"default\":false},{\"name\":\"secondaryAlignment\",\"type\":[\"boolean\",\"null\"],\"doc\":\"This field is true if this alignment is a lower quality linear alignment\\n   for a multiply-mapped read. Defaults to false.\\n\\n   @see primaryAlignment\\n   @see supplementaryAlignment\",\"default\":false},{\"name\":\"supplementaryAlignment\",\"type\":[\"boolean\",\"null\"],\"doc\":\"This field is true if this alignment is a non-primary linear alignment in\\n   a chimeric alignment. Defaults to false.\\n\\n   @see primaryAlignment\\n   @see secondaryAlignment\",\"default\":false},{\"name\":\"mismatchingPositions\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"origQual\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"attributes\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupName\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupSequencingCenter\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupDescription\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupRunDateEpoch\",\"type\":[\"null\",\"long\"],\"default\":null},{\"name\":\"recordGroupFlowOrder\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupKey","Sequence\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupLibrary\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupPredictedMedianInsertSize\",\"type\":[\"null\",\"int\"],\"default\":null},{\"name\":\"recordGroupPlatform\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupPlatformUnit\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupSample\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"mateAlignmentStart\",\"type\":[\"null\",\"long\"],\"doc\":\"The start position of the mate of this read. Should be set to null if the\\n   mate is unaligned, or if the mate does not exist.\",\"default\":null},{\"name\":\"mateAlignmentEnd\",\"type\":[\"null\",\"long\"],\"doc\":\"The end position of the mate of this read. Should be set to null if the\\n   mate is unaligned, or if the mate does not exist.\",\"default\":null},{\"name\":\"mateContig\",\"type\":[\"null\",\"Contig\"],\"doc\":\"The reference contig of the mate of this read. Should be set to null if the\\n   mate is unaligned, or if the mate does not exist.\",\"default\":null}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** Read number within the array of fragment reads. */
  @Deprecated public java.lang.Integer readNum;
  /** The reference sequence details for the reference chromosome that
   this read is aligned to. If the read is unaligned, this field should
   be null. */
  @Deprecated public org.bdgenomics.formats.avro.Contig contig;
  /** 0 based reference position for the start of this read's alignment.
   Should be null if the read is unaligned. */
  @Deprecated public java.lang.Long start;
  /** 0 based reference position where this read used to start before
   local realignment.
   Stores the same data as the OP field in the SAM format. */
  @Deprecated public java.lang.Long oldPosition;
  /** 0 based reference position for the end of this read's alignment.
   Should be null if the read is unaligned. */
  @Deprecated public java.lang.Long end;
  /** The global mapping quality of this read. */
  @Deprecated public java.lang.Integer mapq;
  /** The name of this read. This should be unique within the read group
   that this read is from, and can be used to identify other reads that
   are derived from a single fragment. */
  @Deprecated public java.lang.CharSequence readName;
  /** The bases in this alignment. If the read has been hard clipped, this may
   not represent all the bases in the original read. */
  @Deprecated public java.lang.CharSequence sequence;
  /** The per-base quality scores in this alignment. If the read has been hard
   clipped, this may not represent all the bases in the original read.
   Additionally, if the error scores have been recalibrated, this field
   will not contain the original base quality scores.

   @see origQual */
  @Deprecated public java.lang.CharSequence qual;
  /** The Compact Ideosyncratic Gapped Alignment Report (CIGAR) string that
   describes the local alignment of this read. Contains {length, operator}
   pairs for all contiguous alignment operations. The operators include:

   * M, ALIGNMENT_MATCH: An alignment match indicates that a sequence can be
     aligned to the reference without evidence of an INDEL. Unlike the
     SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the ALIGNMENT_MATCH
     operator does not indicate whether the reference and read sequences are an
     exact match.
   * I, INSERT: The insert operator indicates that the read contains evidence of
     bases being inserted into the reference.
   * D, DELETE: The delete operator indicates that the read contains evidence of
     bases being deleted from the reference.
   * N, SKIP: The skip operator indicates that this read skips a long segment of
     the reference, but the bases have not been deleted. This operator is
     commonly used when working with RNA-seq data, where reads may skip long
     segments of the reference between exons.
   * S, CLIP_SOFT: The soft clip operator indicates that bases at the start/end
     of a read have not been considered during alignment. This may occur if the
     majority of a read maps, except for low quality bases at the start/end of
     a read. Bases that are soft clipped will still be stored in the read.
   * H, CLIP_HARD: The hard clip operator indicates that bases at the start/end of
     a read have been omitted from this alignment. This may occur if this linear
     alignment is part of a chimeric alignment, or if the read has been trimmed
     (e.g., during error correction, or to trim poly-A tails for RNA-seq).
   * P, PAD: The pad operator indicates that there is padding in an alignment.
   * =, SEQUENCE_MATCH: This operator indicates that this portion of the aligned
     sequence exactly matches the reference (e.g., all bases are equal to the
     reference bases).
   * X, SEQUENCE_MISMATCH: This operator indicates that this portion of the
     aligned sequence is an alignment match to the reference, but a sequence
     mismatch (e.g., the bases are not equal to the reference). This can
     indicate a SNP or a read error. */
  @Deprecated public java.lang.CharSequence cigar;
  /** Stores the CIGAR string present before local indel realignment.
   Stores the same data as the OC field in the SAM format.

   @see cigar */
  @Deprecated public java.lang.CharSequence oldCigar;
  /** The number of bases in this read/alignment that have been trimmed from the
   start of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the start of the read has been hard-clipped.

   @see cigar */
  @Deprecated public java.lang.Integer basesTrimmedFromStart;
  /** The number of bases in this read/alignment that have been trimmed from the
   end of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the end of the read has been hard-clipped.

   @see cigar */
  @Deprecated public java.lang.Integer basesTrimmedFromEnd;
  @Deprecated public java.lang.Boolean readPaired;
  @Deprecated public java.lang.Boolean properPair;
  @Deprecated public java.lang.Boolean readMapped;
  @Deprecated public java.lang.Boolean mateMapped;
  @Deprecated public java.lang.Boolean firstOfPair;
  @Deprecated public java.lang.Boolean secondOfPair;
  @Deprecated public java.lang.Boolean failedVendorQualityChecks;
  @Deprecated public java.lang.Boolean duplicateRead;
  /** True if this alignment is mapped as a reverse compliment. This field
   defaults to false. */
  @Deprecated public java.lang.Boolean readNegativeStrand;
  /** True if the mate pair of this alignment is mapped as a reverse compliment.
   This field defaults to false. */
  @Deprecated public java.lang.Boolean mateNegativeStrand;
  /** This field is true if this alignment is either the best linear alignment,
   or the first linear alignment in a chimeric alignment. Defaults to false.

   @see secondaryAlignment
   @see supplementaryAlignment */
  @Deprecated public java.lang.Boolean primaryAlignment;
  /** This field is true if this alignment is a lower quality linear alignment
   for a multiply-mapped read. Defaults to false.

   @see primaryAlignment
   @see supplementaryAlignment */
  @Deprecated public java.lang.Boolean secondaryAlignment;
  /** This field is true if this alignment is a non-primary linear alignment in
   a chimeric alignment. Defaults to false.

   @see primaryAlignment
   @see secondaryAlignment */
  @Deprecated public java.lang.Boolean supplementaryAlignment;
  @Deprecated public java.lang.CharSequence mismatchingPositions;
  @Deprecated public java.lang.CharSequence origQual;
  @Deprecated public java.lang.CharSequence attributes;
  @Deprecated public java.lang.CharSequence recordGroupName;
  @Deprecated public java.lang.CharSequence recordGroupSequencingCenter;
  @Deprecated public java.lang.CharSequence recordGroupDescription;
  @Deprecated public java.lang.Long recordGroupRunDateEpoch;
  @Deprecated public java.lang.CharSequence recordGroupFlowOrder;
  @Deprecated public java.lang.CharSequence recordGroupKeySequence;
  @Deprecated public java.lang.CharSequence recordGroupLibrary;
  @Deprecated public java.lang.Integer recordGroupPredictedMedianInsertSize;
  @Deprecated public java.lang.CharSequence recordGroupPlatform;
  @Deprecated public java.lang.CharSequence recordGroupPlatformUnit;
  @Deprecated public java.lang.CharSequence recordGroupSample;
  /** The start position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist. */
  @Deprecated public java.lang.Long mateAlignmentStart;
  /** The end position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist. */
  @Deprecated public java.lang.Long mateAlignmentEnd;
  /** The reference contig of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist. */
  @Deprecated public org.bdgenomics.formats.avro.Contig mateContig;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public AlignmentRecord() {}

  /**
   * All-args constructor.
   */
  public AlignmentRecord(java.lang.Integer readNum, org.bdgenomics.formats.avro.Contig contig, java.lang.Long start, java.lang.Long oldPosition, java.lang.Long end, java.lang.Integer mapq, java.lang.CharSequence readName, java.lang.CharSequence sequence, java.lang.CharSequence qual, java.lang.CharSequence cigar, java.lang.CharSequence oldCigar, java.lang.Integer basesTrimmedFromStart, java.lang.Integer basesTrimmedFromEnd, java.lang.Boolean readPaired, java.lang.Boolean properPair, java.lang.Boolean readMapped, java.lang.Boolean mateMapped, java.lang.Boolean firstOfPair, java.lang.Boolean secondOfPair, java.lang.Boolean failedVendorQualityChecks, java.lang.Boolean duplicateRead, java.lang.Boolean readNegativeStrand, java.lang.Boolean mateNegativeStrand, java.lang.Boolean primaryAlignment, java.lang.Boolean secondaryAlignment, java.lang.Boolean supplementaryAlignment, java.lang.CharSequence mismatchingPositions, java.lang.CharSequence origQual, java.lang.CharSequence attributes, java.lang.CharSequence recordGroupName, java.lang.CharSequence recordGroupSequencingCenter, java.lang.CharSequence recordGroupDescription, java.lang.Long recordGroupRunDateEpoch, java.lang.CharSequence recordGroupFlowOrder, java.lang.CharSequence recordGroupKeySequence, java.lang.CharSequence recordGroupLibrary, java.lang.Integer recordGroupPredictedMedianInsertSize, java.lang.CharSequence recordGroupPlatform, java.lang.CharSequence recordGroupPlatformUnit, java.lang.CharSequence recordGroupSample, java.lang.Long mateAlignmentStart, java.lang.Long mateAlignmentEnd, org.bdgenomics.formats.avro.Contig mateContig) {
    this.readNum = readNum;
    this.contig = contig;
    this.start = start;
    this.oldPosition = oldPosition;
    this.end = end;
    this.mapq = mapq;
    this.readName = readName;
    this.sequence = sequence;
    this.qual = qual;
    this.cigar = cigar;
    this.oldCigar = oldCigar;
    this.basesTrimmedFromStart = basesTrimmedFromStart;
    this.basesTrimmedFromEnd = basesTrimmedFromEnd;
    this.readPaired = readPaired;
    this.properPair = properPair;
    this.readMapped = readMapped;
    this.mateMapped = mateMapped;
    this.firstOfPair = firstOfPair;
    this.secondOfPair = secondOfPair;
    this.failedVendorQualityChecks = failedVendorQualityChecks;
    this.duplicateRead = duplicateRead;
    this.readNegativeStrand = readNegativeStrand;
    this.mateNegativeStrand = mateNegativeStrand;
    this.primaryAlignment = primaryAlignment;
    this.secondaryAlignment = secondaryAlignment;
    this.supplementaryAlignment = supplementaryAlignment;
    this.mismatchingPositions = mismatchingPositions;
    this.origQual = origQual;
    this.attributes = attributes;
    this.recordGroupName = recordGroupName;
    this.recordGroupSequencingCenter = recordGroupSequencingCenter;
    this.recordGroupDescription = recordGroupDescription;
    this.recordGroupRunDateEpoch = recordGroupRunDateEpoch;
    this.recordGroupFlowOrder = recordGroupFlowOrder;
    this.recordGroupKeySequence = recordGroupKeySequence;
    this.recordGroupLibrary = recordGroupLibrary;
    this.recordGroupPredictedMedianInsertSize = recordGroupPredictedMedianInsertSize;
    this.recordGroupPlatform = recordGroupPlatform;
    this.recordGroupPlatformUnit = recordGroupPlatformUnit;
    this.recordGroupSample = recordGroupSample;
    this.mateAlignmentStart = mateAlignmentStart;
    this.mateAlignmentEnd = mateAlignmentEnd;
    this.mateContig = mateContig;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return readNum;
    case 1: return contig;
    case 2: return start;
    case 3: return oldPosition;
    case 4: return end;
    case 5: return mapq;
    case 6: return readName;
    case 7: return sequence;
    case 8: return qual;
    case 9: return cigar;
    case 10: return oldCigar;
    case 11: return basesTrimmedFromStart;
    case 12: return basesTrimmedFromEnd;
    case 13: return readPaired;
    case 14: return properPair;
    case 15: return readMapped;
    case 16: return mateMapped;
    case 17: return firstOfPair;
    case 18: return secondOfPair;
    case 19: return failedVendorQualityChecks;
    case 20: return duplicateRead;
    case 21: return readNegativeStrand;
    case 22: return mateNegativeStrand;
    case 23: return primaryAlignment;
    case 24: return secondaryAlignment;
    case 25: return supplementaryAlignment;
    case 26: return mismatchingPositions;
    case 27: return origQual;
    case 28: return attributes;
    case 29: return recordGroupName;
    case 30: return recordGroupSequencingCenter;
    case 31: return recordGroupDescription;
    case 32: return recordGroupRunDateEpoch;
    case 33: return recordGroupFlowOrder;
    case 34: return recordGroupKeySequence;
    case 35: return recordGroupLibrary;
    case 36: return recordGroupPredictedMedianInsertSize;
    case 37: return recordGroupPlatform;
    case 38: return recordGroupPlatformUnit;
    case 39: return recordGroupSample;
    case 40: return mateAlignmentStart;
    case 41: return mateAlignmentEnd;
    case 42: return mateContig;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: readNum = (java.lang.Integer)value$; break;
    case 1: contig = (org.bdgenomics.formats.avro.Contig)value$; break;
    case 2: start = (java.lang.Long)value$; break;
    case 3: oldPosition = (java.lang.Long)value$; break;
    case 4: end = (java.lang.Long)value$; break;
    case 5: mapq = (java.lang.Integer)value$; break;
    case 6: readName = (java.lang.CharSequence)value$; break;
    case 7: sequence = (java.lang.CharSequence)value$; break;
    case 8: qual = (java.lang.CharSequence)value$; break;
    case 9: cigar = (java.lang.CharSequence)value$; break;
    case 10: oldCigar = (java.lang.CharSequence)value$; break;
    case 11: basesTrimmedFromStart = (java.lang.Integer)value$; break;
    case 12: basesTrimmedFromEnd = (java.lang.Integer)value$; break;
    case 13: readPaired = (java.lang.Boolean)value$; break;
    case 14: properPair = (java.lang.Boolean)value$; break;
    case 15: readMapped = (java.lang.Boolean)value$; break;
    case 16: mateMapped = (java.lang.Boolean)value$; break;
    case 17: firstOfPair = (java.lang.Boolean)value$; break;
    case 18: secondOfPair = (java.lang.Boolean)value$; break;
    case 19: failedVendorQualityChecks = (java.lang.Boolean)value$; break;
    case 20: duplicateRead = (java.lang.Boolean)value$; break;
    case 21: readNegativeStrand = (java.lang.Boolean)value$; break;
    case 22: mateNegativeStrand = (java.lang.Boolean)value$; break;
    case 23: primaryAlignment = (java.lang.Boolean)value$; break;
    case 24: secondaryAlignment = (java.lang.Boolean)value$; break;
    case 25: supplementaryAlignment = (java.lang.Boolean)value$; break;
    case 26: mismatchingPositions = (java.lang.CharSequence)value$; break;
    case 27: origQual = (java.lang.CharSequence)value$; break;
    case 28: attributes = (java.lang.CharSequence)value$; break;
    case 29: recordGroupName = (java.lang.CharSequence)value$; break;
    case 30: recordGroupSequencingCenter = (java.lang.CharSequence)value$; break;
    case 31: recordGroupDescription = (java.lang.CharSequence)value$; break;
    case 32: recordGroupRunDateEpoch = (java.lang.Long)value$; break;
    case 33: recordGroupFlowOrder = (java.lang.CharSequence)value$; break;
    case 34: recordGroupKeySequence = (java.lang.CharSequence)value$; break;
    case 35: recordGroupLibrary = (java.lang.CharSequence)value$; break;
    case 36: recordGroupPredictedMedianInsertSize = (java.lang.Integer)value$; break;
    case 37: recordGroupPlatform = (java.lang.CharSequence)value$; break;
    case 38: recordGroupPlatformUnit = (java.lang.CharSequence)value$; break;
    case 39: recordGroupSample = (java.lang.CharSequence)value$; break;
    case 40: mateAlignmentStart = (java.lang.Long)value$; break;
    case 41: mateAlignmentEnd = (java.lang.Long)value$; break;
    case 42: mateContig = (org.bdgenomics.formats.avro.Contig)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'readNum' field.
   * Read number within the array of fragment reads.   */
  public java.lang.Integer getReadNum() {
    return readNum;
  }

  /**
   * Sets the value of the 'readNum' field.
   * Read number within the array of fragment reads.   * @param value the value to set.
   */
  public void setReadNum(java.lang.Integer value) {
    this.readNum = value;
  }

  /**
   * Gets the value of the 'contig' field.
   * The reference sequence details for the reference chromosome that
   this read is aligned to. If the read is unaligned, this field should
   be null.   */
  public org.bdgenomics.formats.avro.Contig getContig() {
    return contig;
  }

  /**
   * Sets the value of the 'contig' field.
   * The reference sequence details for the reference chromosome that
   this read is aligned to. If the read is unaligned, this field should
   be null.   * @param value the value to set.
   */
  public void setContig(org.bdgenomics.formats.avro.Contig value) {
    this.contig = value;
  }

  /**
   * Gets the value of the 'start' field.
   * 0 based reference position for the start of this read's alignment.
   Should be null if the read is unaligned.   */
  public java.lang.Long getStart() {
    return start;
  }

  /**
   * Sets the value of the 'start' field.
   * 0 based reference position for the start of this read's alignment.
   Should be null if the read is unaligned.   * @param value the value to set.
   */
  public void setStart(java.lang.Long value) {
    this.start = value;
  }

  /**
   * Gets the value of the 'oldPosition' field.
   * 0 based reference position where this read used to start before
   local realignment.
   Stores the same data as the OP field in the SAM format.   */
  public java.lang.Long getOldPosition() {
    return oldPosition;
  }

  /**
   * Sets the value of the 'oldPosition' field.
   * 0 based reference position where this read used to start before
   local realignment.
   Stores the same data as the OP field in the SAM format.   * @param value the value to set.
   */
  public void setOldPosition(java.lang.Long value) {
    this.oldPosition = value;
  }

  /**
   * Gets the value of the 'end' field.
   * 0 based reference position for the end of this read's alignment.
   Should be null if the read is unaligned.   */
  public java.lang.Long getEnd() {
    return end;
  }

  /**
   * Sets the value of the 'end' field.
   * 0 based reference position for the end of this read's alignment.
   Should be null if the read is unaligned.   * @param value the value to set.
   */
  public void setEnd(java.lang.Long value) {
    this.end = value;
  }

  /**
   * Gets the value of the 'mapq' field.
   * The global mapping quality of this read.   */
  public java.lang.Integer getMapq() {
    return mapq;
  }

  /**
   * Sets the value of the 'mapq' field.
   * The global mapping quality of this read.   * @param value the value to set.
   */
  public void setMapq(java.lang.Integer value) {
    this.mapq = value;
  }

  /**
   * Gets the value of the 'readName' field.
   * The name of this read. This should be unique within the read group
   that this read is from, and can be used to identify other reads that
   are derived from a single fragment.   */
  public java.lang.CharSequence getReadName() {
    return readName;
  }

  /**
   * Sets the value of the 'readName' field.
   * The name of this read. This should be unique within the read group
   that this read is from, and can be used to identify other reads that
   are derived from a single fragment.   * @param value the value to set.
   */
  public void setReadName(java.lang.CharSequence value) {
    this.readName = value;
  }

  /**
   * Gets the value of the 'sequence' field.
   * The bases in this alignment. If the read has been hard clipped, this may
   not represent all the bases in the original read.   */
  public java.lang.CharSequence getSequence() {
    return sequence;
  }

  /**
   * Sets the value of the 'sequence' field.
   * The bases in this alignment. If the read has been hard clipped, this may
   not represent all the bases in the original read.   * @param value the value to set.
   */
  public void setSequence(java.lang.CharSequence value) {
    this.sequence = value;
  }

  /**
   * Gets the value of the 'qual' field.
   * The per-base quality scores in this alignment. If the read has been hard
   clipped, this may not represent all the bases in the original read.
   Additionally, if the error scores have been recalibrated, this field
   will not contain the original base quality scores.

   @see origQual   */
  public java.lang.CharSequence getQual() {
    return qual;
  }

  /**
   * Sets the value of the 'qual' field.
   * The per-base quality scores in this alignment. If the read has been hard
   clipped, this may not represent all the bases in the original read.
   Additionally, if the error scores have been recalibrated, this field
   will not contain the original base quality scores.

   @see origQual   * @param value the value to set.
   */
  public void setQual(java.lang.CharSequence value) {
    this.qual = value;
  }

  /**
   * Gets the value of the 'cigar' field.
   * The Compact Ideosyncratic Gapped Alignment Report (CIGAR) string that
   describes the local alignment of this read. Contains {length, operator}
   pairs for all contiguous alignment operations. The operators include:

   * M, ALIGNMENT_MATCH: An alignment match indicates that a sequence can be
     aligned to the reference without evidence of an INDEL. Unlike the
     SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the ALIGNMENT_MATCH
     operator does not indicate whether the reference and read sequences are an
     exact match.
   * I, INSERT: The insert operator indicates that the read contains evidence of
     bases being inserted into the reference.
   * D, DELETE: The delete operator indicates that the read contains evidence of
     bases being deleted from the reference.
   * N, SKIP: The skip operator indicates that this read skips a long segment of
     the reference, but the bases have not been deleted. This operator is
     commonly used when working with RNA-seq data, where reads may skip long
     segments of the reference between exons.
   * S, CLIP_SOFT: The soft clip operator indicates that bases at the start/end
     of a read have not been considered during alignment. This may occur if the
     majority of a read maps, except for low quality bases at the start/end of
     a read. Bases that are soft clipped will still be stored in the read.
   * H, CLIP_HARD: The hard clip operator indicates that bases at the start/end of
     a read have been omitted from this alignment. This may occur if this linear
     alignment is part of a chimeric alignment, or if the read has been trimmed
     (e.g., during error correction, or to trim poly-A tails for RNA-seq).
   * P, PAD: The pad operator indicates that there is padding in an alignment.
   * =, SEQUENCE_MATCH: This operator indicates that this portion of the aligned
     sequence exactly matches the reference (e.g., all bases are equal to the
     reference bases).
   * X, SEQUENCE_MISMATCH: This operator indicates that this portion of the
     aligned sequence is an alignment match to the reference, but a sequence
     mismatch (e.g., the bases are not equal to the reference). This can
     indicate a SNP or a read error.   */
  public java.lang.CharSequence getCigar() {
    return cigar;
  }

  /**
   * Sets the value of the 'cigar' field.
   * The Compact Ideosyncratic Gapped Alignment Report (CIGAR) string that
   describes the local alignment of this read. Contains {length, operator}
   pairs for all contiguous alignment operations. The operators include:

   * M, ALIGNMENT_MATCH: An alignment match indicates that a sequence can be
     aligned to the reference without evidence of an INDEL. Unlike the
     SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the ALIGNMENT_MATCH
     operator does not indicate whether the reference and read sequences are an
     exact match.
   * I, INSERT: The insert operator indicates that the read contains evidence of
     bases being inserted into the reference.
   * D, DELETE: The delete operator indicates that the read contains evidence of
     bases being deleted from the reference.
   * N, SKIP: The skip operator indicates that this read skips a long segment of
     the reference, but the bases have not been deleted. This operator is
     commonly used when working with RNA-seq data, where reads may skip long
     segments of the reference between exons.
   * S, CLIP_SOFT: The soft clip operator indicates that bases at the start/end
     of a read have not been considered during alignment. This may occur if the
     majority of a read maps, except for low quality bases at the start/end of
     a read. Bases that are soft clipped will still be stored in the read.
   * H, CLIP_HARD: The hard clip operator indicates that bases at the start/end of
     a read have been omitted from this alignment. This may occur if this linear
     alignment is part of a chimeric alignment, or if the read has been trimmed
     (e.g., during error correction, or to trim poly-A tails for RNA-seq).
   * P, PAD: The pad operator indicates that there is padding in an alignment.
   * =, SEQUENCE_MATCH: This operator indicates that this portion of the aligned
     sequence exactly matches the reference (e.g., all bases are equal to the
     reference bases).
   * X, SEQUENCE_MISMATCH: This operator indicates that this portion of the
     aligned sequence is an alignment match to the reference, but a sequence
     mismatch (e.g., the bases are not equal to the reference). This can
     indicate a SNP or a read error.   * @param value the value to set.
   */
  public void setCigar(java.lang.CharSequence value) {
    this.cigar = value;
  }

  /**
   * Gets the value of the 'oldCigar' field.
   * Stores the CIGAR string present before local indel realignment.
   Stores the same data as the OC field in the SAM format.

   @see cigar   */
  public java.lang.CharSequence getOldCigar() {
    return oldCigar;
  }

  /**
   * Sets the value of the 'oldCigar' field.
   * Stores the CIGAR string present before local indel realignment.
   Stores the same data as the OC field in the SAM format.

   @see cigar   * @param value the value to set.
   */
  public void setOldCigar(java.lang.CharSequence value) {
    this.oldCigar = value;
  }

  /**
   * Gets the value of the 'basesTrimmedFromStart' field.
   * The number of bases in this read/alignment that have been trimmed from the
   start of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the start of the read has been hard-clipped.

   @see cigar   */
  public java.lang.Integer getBasesTrimmedFromStart() {
    return basesTrimmedFromStart;
  }

  /**
   * Sets the value of the 'basesTrimmedFromStart' field.
   * The number of bases in this read/alignment that have been trimmed from the
   start of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the start of the read has been hard-clipped.

   @see cigar   * @param value the value to set.
   */
  public void setBasesTrimmedFromStart(java.lang.Integer value) {
    this.basesTrimmedFromStart = value;
  }

  /**
   * Gets the value of the 'basesTrimmedFromEnd' field.
   * The number of bases in this read/alignment that have been trimmed from the
   end of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the end of the read has been hard-clipped.

   @see cigar   */
  public java.lang.Integer getBasesTrimmedFromEnd() {
    return basesTrimmedFromEnd;
  }

  /**
   * Sets the value of the 'basesTrimmedFromEnd' field.
   * The number of bases in this read/alignment that have been trimmed from the
   end of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the end of the read has been hard-clipped.

   @see cigar   * @param value the value to set.
   */
  public void setBasesTrimmedFromEnd(java.lang.Integer value) {
    this.basesTrimmedFromEnd = value;
  }

  /**
   * Gets the value of the 'readPaired' field.
   */
  public java.lang.Boolean getReadPaired() {
    return readPaired;
  }

  /**
   * Sets the value of the 'readPaired' field.
   * @param value the value to set.
   */
  public void setReadPaired(java.lang.Boolean value) {
    this.readPaired = value;
  }

  /**
   * Gets the value of the 'properPair' field.
   */
  public java.lang.Boolean getProperPair() {
    return properPair;
  }

  /**
   * Sets the value of the 'properPair' field.
   * @param value the value to set.
   */
  public void setProperPair(java.lang.Boolean value) {
    this.properPair = value;
  }

  /**
   * Gets the value of the 'readMapped' field.
   */
  public java.lang.Boolean getReadMapped() {
    return readMapped;
  }

  /**
   * Sets the value of the 'readMapped' field.
   * @param value the value to set.
   */
  public void setReadMapped(java.lang.Boolean value) {
    this.readMapped = value;
  }

  /**
   * Gets the value of the 'mateMapped' field.
   */
  public java.lang.Boolean getMateMapped() {
    return mateMapped;
  }

  /**
   * Sets the value of the 'mateMapped' field.
   * @param value the value to set.
   */
  public void setMateMapped(java.lang.Boolean value) {
    this.mateMapped = value;
  }

  /**
   * Gets the value of the 'firstOfPair' field.
   */
  public java.lang.Boolean getFirstOfPair() {
    return firstOfPair;
  }

  /**
   * Sets the value of the 'firstOfPair' field.
   * @param value the value to set.
   */
  public void setFirstOfPair(java.lang.Boolean value) {
    this.firstOfPair = value;
  }

  /**
   * Gets the value of the 'secondOfPair' field.
   */
  public java.lang.Boolean getSecondOfPair() {
    return secondOfPair;
  }

  /**
   * Sets the value of the 'secondOfPair' field.
   * @param value the value to set.
   */
  public void setSecondOfPair(java.lang.Boolean value) {
    this.secondOfPair = value;
  }

  /**
   * Gets the value of the 'failedVendorQualityChecks' field.
   */
  public java.lang.Boolean getFailedVendorQualityChecks() {
    return failedVendorQualityChecks;
  }

  /**
   * Sets the value of the 'failedVendorQualityChecks' field.
   * @param value the value to set.
   */
  public void setFailedVendorQualityChecks(java.lang.Boolean value) {
    this.failedVendorQualityChecks = value;
  }

  /**
   * Gets the value of the 'duplicateRead' field.
   */
  public java.lang.Boolean getDuplicateRead() {
    return duplicateRead;
  }

  /**
   * Sets the value of the 'duplicateRead' field.
   * @param value the value to set.
   */
  public void setDuplicateRead(java.lang.Boolean value) {
    this.duplicateRead = value;
  }

  /**
   * Gets the value of the 'readNegativeStrand' field.
   * True if this alignment is mapped as a reverse compliment. This field
   defaults to false.   */
  public java.lang.Boolean getReadNegativeStrand() {
    return readNegativeStrand;
  }

  /**
   * Sets the value of the 'readNegativeStrand' field.
   * True if this alignment is mapped as a reverse compliment. This field
   defaults to false.   * @param value the value to set.
   */
  public void setReadNegativeStrand(java.lang.Boolean value) {
    this.readNegativeStrand = value;
  }

  /**
   * Gets the value of the 'mateNegativeStrand' field.
   * True if the mate pair of this alignment is mapped as a reverse compliment.
   This field defaults to false.   */
  public java.lang.Boolean getMateNegativeStrand() {
    return mateNegativeStrand;
  }

  /**
   * Sets the value of the 'mateNegativeStrand' field.
   * True if the mate pair of this alignment is mapped as a reverse compliment.
   This field defaults to false.   * @param value the value to set.
   */
  public void setMateNegativeStrand(java.lang.Boolean value) {
    this.mateNegativeStrand = value;
  }

  /**
   * Gets the value of the 'primaryAlignment' field.
   * This field is true if this alignment is either the best linear alignment,
   or the first linear alignment in a chimeric alignment. Defaults to false.

   @see secondaryAlignment
   @see supplementaryAlignment   */
  public java.lang.Boolean getPrimaryAlignment() {
    return primaryAlignment;
  }

  /**
   * Sets the value of the 'primaryAlignment' field.
   * This field is true if this alignment is either the best linear alignment,
   or the first linear alignment in a chimeric alignment. Defaults to false.

   @see secondaryAlignment
   @see supplementaryAlignment   * @param value the value to set.
   */
  public void setPrimaryAlignment(java.lang.Boolean value) {
    this.primaryAlignment = value;
  }

  /**
   * Gets the value of the 'secondaryAlignment' field.
   * This field is true if this alignment is a lower quality linear alignment
   for a multiply-mapped read. Defaults to false.

   @see primaryAlignment
   @see supplementaryAlignment   */
  public java.lang.Boolean getSecondaryAlignment() {
    return secondaryAlignment;
  }

  /**
   * Sets the value of the 'secondaryAlignment' field.
   * This field is true if this alignment is a lower quality linear alignment
   for a multiply-mapped read. Defaults to false.

   @see primaryAlignment
   @see supplementaryAlignment   * @param value the value to set.
   */
  public void setSecondaryAlignment(java.lang.Boolean value) {
    this.secondaryAlignment = value;
  }

  /**
   * Gets the value of the 'supplementaryAlignment' field.
   * This field is true if this alignment is a non-primary linear alignment in
   a chimeric alignment. Defaults to false.

   @see primaryAlignment
   @see secondaryAlignment   */
  public java.lang.Boolean getSupplementaryAlignment() {
    return supplementaryAlignment;
  }

  /**
   * Sets the value of the 'supplementaryAlignment' field.
   * This field is true if this alignment is a non-primary linear alignment in
   a chimeric alignment. Defaults to false.

   @see primaryAlignment
   @see secondaryAlignment   * @param value the value to set.
   */
  public void setSupplementaryAlignment(java.lang.Boolean value) {
    this.supplementaryAlignment = value;
  }

  /**
   * Gets the value of the 'mismatchingPositions' field.
   */
  public java.lang.CharSequence getMismatchingPositions() {
    return mismatchingPositions;
  }

  /**
   * Sets the value of the 'mismatchingPositions' field.
   * @param value the value to set.
   */
  public void setMismatchingPositions(java.lang.CharSequence value) {
    this.mismatchingPositions = value;
  }

  /**
   * Gets the value of the 'origQual' field.
   */
  public java.lang.CharSequence getOrigQual() {
    return origQual;
  }

  /**
   * Sets the value of the 'origQual' field.
   * @param value the value to set.
   */
  public void setOrigQual(java.lang.CharSequence value) {
    this.origQual = value;
  }

  /**
   * Gets the value of the 'attributes' field.
   */
  public java.lang.CharSequence getAttributes() {
    return attributes;
  }

  /**
   * Sets the value of the 'attributes' field.
   * @param value the value to set.
   */
  public void setAttributes(java.lang.CharSequence value) {
    this.attributes = value;
  }

  /**
   * Gets the value of the 'recordGroupName' field.
   */
  public java.lang.CharSequence getRecordGroupName() {
    return recordGroupName;
  }

  /**
   * Sets the value of the 'recordGroupName' field.
   * @param value the value to set.
   */
  public void setRecordGroupName(java.lang.CharSequence value) {
    this.recordGroupName = value;
  }

  /**
   * Gets the value of the 'recordGroupSequencingCenter' field.
   */
  public java.lang.CharSequence getRecordGroupSequencingCenter() {
    return recordGroupSequencingCenter;
  }

  /**
   * Sets the value of the 'recordGroupSequencingCenter' field.
   * @param value the value to set.
   */
  public void setRecordGroupSequencingCenter(java.lang.CharSequence value) {
    this.recordGroupSequencingCenter = value;
  }

  /**
   * Gets the value of the 'recordGroupDescription' field.
   */
  public java.lang.CharSequence getRecordGroupDescription() {
    return recordGroupDescription;
  }

  /**
   * Sets the value of the 'recordGroupDescription' field.
   * @param value the value to set.
   */
  public void setRecordGroupDescription(java.lang.CharSequence value) {
    this.recordGroupDescription = value;
  }

  /**
   * Gets the value of the 'recordGroupRunDateEpoch' field.
   */
  public java.lang.Long getRecordGroupRunDateEpoch() {
    return recordGroupRunDateEpoch;
  }

  /**
   * Sets the value of the 'recordGroupRunDateEpoch' field.
   * @param value the value to set.
   */
  public void setRecordGroupRunDateEpoch(java.lang.Long value) {
    this.recordGroupRunDateEpoch = value;
  }

  /**
   * Gets the value of the 'recordGroupFlowOrder' field.
   */
  public java.lang.CharSequence getRecordGroupFlowOrder() {
    return recordGroupFlowOrder;
  }

  /**
   * Sets the value of the 'recordGroupFlowOrder' field.
   * @param value the value to set.
   */
  public void setRecordGroupFlowOrder(java.lang.CharSequence value) {
    this.recordGroupFlowOrder = value;
  }

  /**
   * Gets the value of the 'recordGroupKeySequence' field.
   */
  public java.lang.CharSequence getRecordGroupKeySequence() {
    return recordGroupKeySequence;
  }

  /**
   * Sets the value of the 'recordGroupKeySequence' field.
   * @param value the value to set.
   */
  public void setRecordGroupKeySequence(java.lang.CharSequence value) {
    this.recordGroupKeySequence = value;
  }

  /**
   * Gets the value of the 'recordGroupLibrary' field.
   */
  public java.lang.CharSequence getRecordGroupLibrary() {
    return recordGroupLibrary;
  }

  /**
   * Sets the value of the 'recordGroupLibrary' field.
   * @param value the value to set.
   */
  public void setRecordGroupLibrary(java.lang.CharSequence value) {
    this.recordGroupLibrary = value;
  }

  /**
   * Gets the value of the 'recordGroupPredictedMedianInsertSize' field.
   */
  public java.lang.Integer getRecordGroupPredictedMedianInsertSize() {
    return recordGroupPredictedMedianInsertSize;
  }

  /**
   * Sets the value of the 'recordGroupPredictedMedianInsertSize' field.
   * @param value the value to set.
   */
  public void setRecordGroupPredictedMedianInsertSize(java.lang.Integer value) {
    this.recordGroupPredictedMedianInsertSize = value;
  }

  /**
   * Gets the value of the 'recordGroupPlatform' field.
   */
  public java.lang.CharSequence getRecordGroupPlatform() {
    return recordGroupPlatform;
  }

  /**
   * Sets the value of the 'recordGroupPlatform' field.
   * @param value the value to set.
   */
  public void setRecordGroupPlatform(java.lang.CharSequence value) {
    this.recordGroupPlatform = value;
  }

  /**
   * Gets the value of the 'recordGroupPlatformUnit' field.
   */
  public java.lang.CharSequence getRecordGroupPlatformUnit() {
    return recordGroupPlatformUnit;
  }

  /**
   * Sets the value of the 'recordGroupPlatformUnit' field.
   * @param value the value to set.
   */
  public void setRecordGroupPlatformUnit(java.lang.CharSequence value) {
    this.recordGroupPlatformUnit = value;
  }

  /**
   * Gets the value of the 'recordGroupSample' field.
   */
  public java.lang.CharSequence getRecordGroupSample() {
    return recordGroupSample;
  }

  /**
   * Sets the value of the 'recordGroupSample' field.
   * @param value the value to set.
   */
  public void setRecordGroupSample(java.lang.CharSequence value) {
    this.recordGroupSample = value;
  }

  /**
   * Gets the value of the 'mateAlignmentStart' field.
   * The start position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   */
  public java.lang.Long getMateAlignmentStart() {
    return mateAlignmentStart;
  }

  /**
   * Sets the value of the 'mateAlignmentStart' field.
   * The start position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   * @param value the value to set.
   */
  public void setMateAlignmentStart(java.lang.Long value) {
    this.mateAlignmentStart = value;
  }

  /**
   * Gets the value of the 'mateAlignmentEnd' field.
   * The end position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   */
  public java.lang.Long getMateAlignmentEnd() {
    return mateAlignmentEnd;
  }

  /**
   * Sets the value of the 'mateAlignmentEnd' field.
   * The end position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   * @param value the value to set.
   */
  public void setMateAlignmentEnd(java.lang.Long value) {
    this.mateAlignmentEnd = value;
  }

  /**
   * Gets the value of the 'mateContig' field.
   * The reference contig of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   */
  public org.bdgenomics.formats.avro.Contig getMateContig() {
    return mateContig;
  }

  /**
   * Sets the value of the 'mateContig' field.
   * The reference contig of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   * @param value the value to set.
   */
  public void setMateContig(org.bdgenomics.formats.avro.Contig value) {
    this.mateContig = value;
  }

  /** Creates a new AlignmentRecord RecordBuilder */
  public static org.bdgenomics.formats.avro.AlignmentRecord.Builder newBuilder() {
    return new org.bdgenomics.formats.avro.AlignmentRecord.Builder();
  }
  
  /** Creates a new AlignmentRecord RecordBuilder by copying an existing Builder */
  public static org.bdgenomics.formats.avro.AlignmentRecord.Builder newBuilder(org.bdgenomics.formats.avro.AlignmentRecord.Builder other) {
    return new org.bdgenomics.formats.avro.AlignmentRecord.Builder(other);
  }
  
  /** Creates a new AlignmentRecord RecordBuilder by copying an existing AlignmentRecord instance */
  public static org.bdgenomics.formats.avro.AlignmentRecord.Builder newBuilder(org.bdgenomics.formats.avro.AlignmentRecord other) {
    return new org.bdgenomics.formats.avro.AlignmentRecord.Builder(other);
  }
  
  /**
   * RecordBuilder for AlignmentRecord instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<AlignmentRecord>
    implements org.apache.avro.data.RecordBuilder<AlignmentRecord> {

    private java.lang.Integer readNum;
    private org.bdgenomics.formats.avro.Contig contig;
    private java.lang.Long start;
    private java.lang.Long oldPosition;
    private java.lang.Long end;
    private java.lang.Integer mapq;
    private java.lang.CharSequence readName;
    private java.lang.CharSequence sequence;
    private java.lang.CharSequence qual;
    private java.lang.CharSequence cigar;
    private java.lang.CharSequence oldCigar;
    private java.lang.Integer basesTrimmedFromStart;
    private java.lang.Integer basesTrimmedFromEnd;
    private java.lang.Boolean readPaired;
    private java.lang.Boolean properPair;
    private java.lang.Boolean readMapped;
    private java.lang.Boolean mateMapped;
    private java.lang.Boolean firstOfPair;
    private java.lang.Boolean secondOfPair;
    private java.lang.Boolean failedVendorQualityChecks;
    private java.lang.Boolean duplicateRead;
    private java.lang.Boolean readNegativeStrand;
    private java.lang.Boolean mateNegativeStrand;
    private java.lang.Boolean primaryAlignment;
    private java.lang.Boolean secondaryAlignment;
    private java.lang.Boolean supplementaryAlignment;
    private java.lang.CharSequence mismatchingPositions;
    private java.lang.CharSequence origQual;
    private java.lang.CharSequence attributes;
    private java.lang.CharSequence recordGroupName;
    private java.lang.CharSequence recordGroupSequencingCenter;
    private java.lang.CharSequence recordGroupDescription;
    private java.lang.Long recordGroupRunDateEpoch;
    private java.lang.CharSequence recordGroupFlowOrder;
    private java.lang.CharSequence recordGroupKeySequence;
    private java.lang.CharSequence recordGroupLibrary;
    private java.lang.Integer recordGroupPredictedMedianInsertSize;
    private java.lang.CharSequence recordGroupPlatform;
    private java.lang.CharSequence recordGroupPlatformUnit;
    private java.lang.CharSequence recordGroupSample;
    private java.lang.Long mateAlignmentStart;
    private java.lang.Long mateAlignmentEnd;
    private org.bdgenomics.formats.avro.Contig mateContig;

    /** Creates a new Builder */
    private Builder() {
      super(org.bdgenomics.formats.avro.AlignmentRecord.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(org.bdgenomics.formats.avro.AlignmentRecord.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.readNum)) {
        this.readNum = data().deepCopy(fields()[0].schema(), other.readNum);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.contig)) {
        this.contig = data().deepCopy(fields()[1].schema(), other.contig);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.start)) {
        this.start = data().deepCopy(fields()[2].schema(), other.start);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.oldPosition)) {
        this.oldPosition = data().deepCopy(fields()[3].schema(), other.oldPosition);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.end)) {
        this.end = data().deepCopy(fields()[4].schema(), other.end);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.mapq)) {
        this.mapq = data().deepCopy(fields()[5].schema(), other.mapq);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.readName)) {
        this.readName = data().deepCopy(fields()[6].schema(), other.readName);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.sequence)) {
        this.sequence = data().deepCopy(fields()[7].schema(), other.sequence);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.qual)) {
        this.qual = data().deepCopy(fields()[8].schema(), other.qual);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.cigar)) {
        this.cigar = data().deepCopy(fields()[9].schema(), other.cigar);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.oldCigar)) {
        this.oldCigar = data().deepCopy(fields()[10].schema(), other.oldCigar);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.basesTrimmedFromStart)) {
        this.basesTrimmedFromStart = data().deepCopy(fields()[11].schema(), other.basesTrimmedFromStart);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.basesTrimmedFromEnd)) {
        this.basesTrimmedFromEnd = data().deepCopy(fields()[12].schema(), other.basesTrimmedFromEnd);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.readPaired)) {
        this.readPaired = data().deepCopy(fields()[13].schema(), other.readPaired);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.properPair)) {
        this.properPair = data().deepCopy(fields()[14].schema(), other.properPair);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.readMapped)) {
        this.readMapped = data().deepCopy(fields()[15].schema(), other.readMapped);
        fieldSetFlags()[15] = true;
      }
      if (isValidValue(fields()[16], other.mateMapped)) {
        this.mateMapped = data().deepCopy(fields()[16].schema(), other.mateMapped);
        fieldSetFlags()[16] = true;
      }
      if (isValidValue(fields()[17], other.firstOfPair)) {
        this.firstOfPair = data().deepCopy(fields()[17].schema(), other.firstOfPair);
        fieldSetFlags()[17] = true;
      }
      if (isValidValue(fields()[18], other.secondOfPair)) {
        this.secondOfPair = data().deepCopy(fields()[18].schema(), other.secondOfPair);
        fieldSetFlags()[18] = true;
      }
      if (isValidValue(fields()[19], other.failedVendorQualityChecks)) {
        this.failedVendorQualityChecks = data().deepCopy(fields()[19].schema(), other.failedVendorQualityChecks);
        fieldSetFlags()[19] = true;
      }
      if (isValidValue(fields()[20], other.duplicateRead)) {
        this.duplicateRead = data().deepCopy(fields()[20].schema(), other.duplicateRead);
        fieldSetFlags()[20] = true;
      }
      if (isValidValue(fields()[21], other.readNegativeStrand)) {
        this.readNegativeStrand = data().deepCopy(fields()[21].schema(), other.readNegativeStrand);
        fieldSetFlags()[21] = true;
      }
      if (isValidValue(fields()[22], other.mateNegativeStrand)) {
        this.mateNegativeStrand = data().deepCopy(fields()[22].schema(), other.mateNegativeStrand);
        fieldSetFlags()[22] = true;
      }
      if (isValidValue(fields()[23], other.primaryAlignment)) {
        this.primaryAlignment = data().deepCopy(fields()[23].schema(), other.primaryAlignment);
        fieldSetFlags()[23] = true;
      }
      if (isValidValue(fields()[24], other.secondaryAlignment)) {
        this.secondaryAlignment = data().deepCopy(fields()[24].schema(), other.secondaryAlignment);
        fieldSetFlags()[24] = true;
      }
      if (isValidValue(fields()[25], other.supplementaryAlignment)) {
        this.supplementaryAlignment = data().deepCopy(fields()[25].schema(), other.supplementaryAlignment);
        fieldSetFlags()[25] = true;
      }
      if (isValidValue(fields()[26], other.mismatchingPositions)) {
        this.mismatchingPositions = data().deepCopy(fields()[26].schema(), other.mismatchingPositions);
        fieldSetFlags()[26] = true;
      }
      if (isValidValue(fields()[27], other.origQual)) {
        this.origQual = data().deepCopy(fields()[27].schema(), other.origQual);
        fieldSetFlags()[27] = true;
      }
      if (isValidValue(fields()[28], other.attributes)) {
        this.attributes = data().deepCopy(fields()[28].schema(), other.attributes);
        fieldSetFlags()[28] = true;
      }
      if (isValidValue(fields()[29], other.recordGroupName)) {
        this.recordGroupName = data().deepCopy(fields()[29].schema(), other.recordGroupName);
        fieldSetFlags()[29] = true;
      }
      if (isValidValue(fields()[30], other.recordGroupSequencingCenter)) {
        this.recordGroupSequencingCenter = data().deepCopy(fields()[30].schema(), other.recordGroupSequencingCenter);
        fieldSetFlags()[30] = true;
      }
      if (isValidValue(fields()[31], other.recordGroupDescription)) {
        this.recordGroupDescription = data().deepCopy(fields()[31].schema(), other.recordGroupDescription);
        fieldSetFlags()[31] = true;
      }
      if (isValidValue(fields()[32], other.recordGroupRunDateEpoch)) {
        this.recordGroupRunDateEpoch = data().deepCopy(fields()[32].schema(), other.recordGroupRunDateEpoch);
        fieldSetFlags()[32] = true;
      }
      if (isValidValue(fields()[33], other.recordGroupFlowOrder)) {
        this.recordGroupFlowOrder = data().deepCopy(fields()[33].schema(), other.recordGroupFlowOrder);
        fieldSetFlags()[33] = true;
      }
      if (isValidValue(fields()[34], other.recordGroupKeySequence)) {
        this.recordGroupKeySequence = data().deepCopy(fields()[34].schema(), other.recordGroupKeySequence);
        fieldSetFlags()[34] = true;
      }
      if (isValidValue(fields()[35], other.recordGroupLibrary)) {
        this.recordGroupLibrary = data().deepCopy(fields()[35].schema(), other.recordGroupLibrary);
        fieldSetFlags()[35] = true;
      }
      if (isValidValue(fields()[36], other.recordGroupPredictedMedianInsertSize)) {
        this.recordGroupPredictedMedianInsertSize = data().deepCopy(fields()[36].schema(), other.recordGroupPredictedMedianInsertSize);
        fieldSetFlags()[36] = true;
      }
      if (isValidValue(fields()[37], other.recordGroupPlatform)) {
        this.recordGroupPlatform = data().deepCopy(fields()[37].schema(), other.recordGroupPlatform);
        fieldSetFlags()[37] = true;
      }
      if (isValidValue(fields()[38], other.recordGroupPlatformUnit)) {
        this.recordGroupPlatformUnit = data().deepCopy(fields()[38].schema(), other.recordGroupPlatformUnit);
        fieldSetFlags()[38] = true;
      }
      if (isValidValue(fields()[39], other.recordGroupSample)) {
        this.recordGroupSample = data().deepCopy(fields()[39].schema(), other.recordGroupSample);
        fieldSetFlags()[39] = true;
      }
      if (isValidValue(fields()[40], other.mateAlignmentStart)) {
        this.mateAlignmentStart = data().deepCopy(fields()[40].schema(), other.mateAlignmentStart);
        fieldSetFlags()[40] = true;
      }
      if (isValidValue(fields()[41], other.mateAlignmentEnd)) {
        this.mateAlignmentEnd = data().deepCopy(fields()[41].schema(), other.mateAlignmentEnd);
        fieldSetFlags()[41] = true;
      }
      if (isValidValue(fields()[42], other.mateContig)) {
        this.mateContig = data().deepCopy(fields()[42].schema(), other.mateContig);
        fieldSetFlags()[42] = true;
      }
    }
    
    /** Creates a Builder by copying an existing AlignmentRecord instance */
    private Builder(org.bdgenomics.formats.avro.AlignmentRecord other) {
            super(org.bdgenomics.formats.avro.AlignmentRecord.SCHEMA$);
      if (isValidValue(fields()[0], other.readNum)) {
        this.readNum = data().deepCopy(fields()[0].schema(), other.readNum);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.contig)) {
        this.contig = data().deepCopy(fields()[1].schema(), other.contig);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.start)) {
        this.start = data().deepCopy(fields()[2].schema(), other.start);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.oldPosition)) {
        this.oldPosition = data().deepCopy(fields()[3].schema(), other.oldPosition);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.end)) {
        this.end = data().deepCopy(fields()[4].schema(), other.end);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.mapq)) {
        this.mapq = data().deepCopy(fields()[5].schema(), other.mapq);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.readName)) {
        this.readName = data().deepCopy(fields()[6].schema(), other.readName);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.sequence)) {
        this.sequence = data().deepCopy(fields()[7].schema(), other.sequence);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.qual)) {
        this.qual = data().deepCopy(fields()[8].schema(), other.qual);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.cigar)) {
        this.cigar = data().deepCopy(fields()[9].schema(), other.cigar);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.oldCigar)) {
        this.oldCigar = data().deepCopy(fields()[10].schema(), other.oldCigar);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.basesTrimmedFromStart)) {
        this.basesTrimmedFromStart = data().deepCopy(fields()[11].schema(), other.basesTrimmedFromStart);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.basesTrimmedFromEnd)) {
        this.basesTrimmedFromEnd = data().deepCopy(fields()[12].schema(), other.basesTrimmedFromEnd);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.readPaired)) {
        this.readPaired = data().deepCopy(fields()[13].schema(), other.readPaired);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.properPair)) {
        this.properPair = data().deepCopy(fields()[14].schema(), other.properPair);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.readMapped)) {
        this.readMapped = data().deepCopy(fields()[15].schema(), other.readMapped);
        fieldSetFlags()[15] = true;
      }
      if (isValidValue(fields()[16], other.mateMapped)) {
        this.mateMapped = data().deepCopy(fields()[16].schema(), other.mateMapped);
        fieldSetFlags()[16] = true;
      }
      if (isValidValue(fields()[17], other.firstOfPair)) {
        this.firstOfPair = data().deepCopy(fields()[17].schema(), other.firstOfPair);
        fieldSetFlags()[17] = true;
      }
      if (isValidValue(fields()[18], other.secondOfPair)) {
        this.secondOfPair = data().deepCopy(fields()[18].schema(), other.secondOfPair);
        fieldSetFlags()[18] = true;
      }
      if (isValidValue(fields()[19], other.failedVendorQualityChecks)) {
        this.failedVendorQualityChecks = data().deepCopy(fields()[19].schema(), other.failedVendorQualityChecks);
        fieldSetFlags()[19] = true;
      }
      if (isValidValue(fields()[20], other.duplicateRead)) {
        this.duplicateRead = data().deepCopy(fields()[20].schema(), other.duplicateRead);
        fieldSetFlags()[20] = true;
      }
      if (isValidValue(fields()[21], other.readNegativeStrand)) {
        this.readNegativeStrand = data().deepCopy(fields()[21].schema(), other.readNegativeStrand);
        fieldSetFlags()[21] = true;
      }
      if (isValidValue(fields()[22], other.mateNegativeStrand)) {
        this.mateNegativeStrand = data().deepCopy(fields()[22].schema(), other.mateNegativeStrand);
        fieldSetFlags()[22] = true;
      }
      if (isValidValue(fields()[23], other.primaryAlignment)) {
        this.primaryAlignment = data().deepCopy(fields()[23].schema(), other.primaryAlignment);
        fieldSetFlags()[23] = true;
      }
      if (isValidValue(fields()[24], other.secondaryAlignment)) {
        this.secondaryAlignment = data().deepCopy(fields()[24].schema(), other.secondaryAlignment);
        fieldSetFlags()[24] = true;
      }
      if (isValidValue(fields()[25], other.supplementaryAlignment)) {
        this.supplementaryAlignment = data().deepCopy(fields()[25].schema(), other.supplementaryAlignment);
        fieldSetFlags()[25] = true;
      }
      if (isValidValue(fields()[26], other.mismatchingPositions)) {
        this.mismatchingPositions = data().deepCopy(fields()[26].schema(), other.mismatchingPositions);
        fieldSetFlags()[26] = true;
      }
      if (isValidValue(fields()[27], other.origQual)) {
        this.origQual = data().deepCopy(fields()[27].schema(), other.origQual);
        fieldSetFlags()[27] = true;
      }
      if (isValidValue(fields()[28], other.attributes)) {
        this.attributes = data().deepCopy(fields()[28].schema(), other.attributes);
        fieldSetFlags()[28] = true;
      }
      if (isValidValue(fields()[29], other.recordGroupName)) {
        this.recordGroupName = data().deepCopy(fields()[29].schema(), other.recordGroupName);
        fieldSetFlags()[29] = true;
      }
      if (isValidValue(fields()[30], other.recordGroupSequencingCenter)) {
        this.recordGroupSequencingCenter = data().deepCopy(fields()[30].schema(), other.recordGroupSequencingCenter);
        fieldSetFlags()[30] = true;
      }
      if (isValidValue(fields()[31], other.recordGroupDescription)) {
        this.recordGroupDescription = data().deepCopy(fields()[31].schema(), other.recordGroupDescription);
        fieldSetFlags()[31] = true;
      }
      if (isValidValue(fields()[32], other.recordGroupRunDateEpoch)) {
        this.recordGroupRunDateEpoch = data().deepCopy(fields()[32].schema(), other.recordGroupRunDateEpoch);
        fieldSetFlags()[32] = true;
      }
      if (isValidValue(fields()[33], other.recordGroupFlowOrder)) {
        this.recordGroupFlowOrder = data().deepCopy(fields()[33].schema(), other.recordGroupFlowOrder);
        fieldSetFlags()[33] = true;
      }
      if (isValidValue(fields()[34], other.recordGroupKeySequence)) {
        this.recordGroupKeySequence = data().deepCopy(fields()[34].schema(), other.recordGroupKeySequence);
        fieldSetFlags()[34] = true;
      }
      if (isValidValue(fields()[35], other.recordGroupLibrary)) {
        this.recordGroupLibrary = data().deepCopy(fields()[35].schema(), other.recordGroupLibrary);
        fieldSetFlags()[35] = true;
      }
      if (isValidValue(fields()[36], other.recordGroupPredictedMedianInsertSize)) {
        this.recordGroupPredictedMedianInsertSize = data().deepCopy(fields()[36].schema(), other.recordGroupPredictedMedianInsertSize);
        fieldSetFlags()[36] = true;
      }
      if (isValidValue(fields()[37], other.recordGroupPlatform)) {
        this.recordGroupPlatform = data().deepCopy(fields()[37].schema(), other.recordGroupPlatform);
        fieldSetFlags()[37] = true;
      }
      if (isValidValue(fields()[38], other.recordGroupPlatformUnit)) {
        this.recordGroupPlatformUnit = data().deepCopy(fields()[38].schema(), other.recordGroupPlatformUnit);
        fieldSetFlags()[38] = true;
      }
      if (isValidValue(fields()[39], other.recordGroupSample)) {
        this.recordGroupSample = data().deepCopy(fields()[39].schema(), other.recordGroupSample);
        fieldSetFlags()[39] = true;
      }
      if (isValidValue(fields()[40], other.mateAlignmentStart)) {
        this.mateAlignmentStart = data().deepCopy(fields()[40].schema(), other.mateAlignmentStart);
        fieldSetFlags()[40] = true;
      }
      if (isValidValue(fields()[41], other.mateAlignmentEnd)) {
        this.mateAlignmentEnd = data().deepCopy(fields()[41].schema(), other.mateAlignmentEnd);
        fieldSetFlags()[41] = true;
      }
      if (isValidValue(fields()[42], other.mateContig)) {
        this.mateContig = data().deepCopy(fields()[42].schema(), other.mateContig);
        fieldSetFlags()[42] = true;
      }
    }

    /** Gets the value of the 'readNum' field */
    public java.lang.Integer getReadNum() {
      return readNum;
    }
    
    /** Sets the value of the 'readNum' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setReadNum(java.lang.Integer value) {
      validate(fields()[0], value);
      this.readNum = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'readNum' field has been set */
    public boolean hasReadNum() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'readNum' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearReadNum() {
      readNum = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'contig' field */
    public org.bdgenomics.formats.avro.Contig getContig() {
      return contig;
    }
    
    /** Sets the value of the 'contig' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setContig(org.bdgenomics.formats.avro.Contig value) {
      validate(fields()[1], value);
      this.contig = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'contig' field has been set */
    public boolean hasContig() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'contig' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearContig() {
      contig = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'start' field */
    public java.lang.Long getStart() {
      return start;
    }
    
    /** Sets the value of the 'start' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setStart(java.lang.Long value) {
      validate(fields()[2], value);
      this.start = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'start' field has been set */
    public boolean hasStart() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'start' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearStart() {
      start = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'oldPosition' field */
    public java.lang.Long getOldPosition() {
      return oldPosition;
    }
    
    /** Sets the value of the 'oldPosition' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setOldPosition(java.lang.Long value) {
      validate(fields()[3], value);
      this.oldPosition = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'oldPosition' field has been set */
    public boolean hasOldPosition() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'oldPosition' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearOldPosition() {
      oldPosition = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'end' field */
    public java.lang.Long getEnd() {
      return end;
    }
    
    /** Sets the value of the 'end' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setEnd(java.lang.Long value) {
      validate(fields()[4], value);
      this.end = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'end' field has been set */
    public boolean hasEnd() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'end' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearEnd() {
      end = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /** Gets the value of the 'mapq' field */
    public java.lang.Integer getMapq() {
      return mapq;
    }
    
    /** Sets the value of the 'mapq' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMapq(java.lang.Integer value) {
      validate(fields()[5], value);
      this.mapq = value;
      fieldSetFlags()[5] = true;
      return this; 
    }
    
    /** Checks whether the 'mapq' field has been set */
    public boolean hasMapq() {
      return fieldSetFlags()[5];
    }
    
    /** Clears the value of the 'mapq' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMapq() {
      mapq = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /** Gets the value of the 'readName' field */
    public java.lang.CharSequence getReadName() {
      return readName;
    }
    
    /** Sets the value of the 'readName' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setReadName(java.lang.CharSequence value) {
      validate(fields()[6], value);
      this.readName = value;
      fieldSetFlags()[6] = true;
      return this; 
    }
    
    /** Checks whether the 'readName' field has been set */
    public boolean hasReadName() {
      return fieldSetFlags()[6];
    }
    
    /** Clears the value of the 'readName' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearReadName() {
      readName = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /** Gets the value of the 'sequence' field */
    public java.lang.CharSequence getSequence() {
      return sequence;
    }
    
    /** Sets the value of the 'sequence' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setSequence(java.lang.CharSequence value) {
      validate(fields()[7], value);
      this.sequence = value;
      fieldSetFlags()[7] = true;
      return this; 
    }
    
    /** Checks whether the 'sequence' field has been set */
    public boolean hasSequence() {
      return fieldSetFlags()[7];
    }
    
    /** Clears the value of the 'sequence' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearSequence() {
      sequence = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    /** Gets the value of the 'qual' field */
    public java.lang.CharSequence getQual() {
      return qual;
    }
    
    /** Sets the value of the 'qual' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setQual(java.lang.CharSequence value) {
      validate(fields()[8], value);
      this.qual = value;
      fieldSetFlags()[8] = true;
      return this; 
    }
    
    /** Checks whether the 'qual' field has been set */
    public boolean hasQual() {
      return fieldSetFlags()[8];
    }
    
    /** Clears the value of the 'qual' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearQual() {
      qual = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    /** Gets the value of the 'cigar' field */
    public java.lang.CharSequence getCigar() {
      return cigar;
    }
    
    /** Sets the value of the 'cigar' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setCigar(java.lang.CharSequence value) {
      validate(fields()[9], value);
      this.cigar = value;
      fieldSetFlags()[9] = true;
      return this; 
    }
    
    /** Checks whether the 'cigar' field has been set */
    public boolean hasCigar() {
      return fieldSetFlags()[9];
    }
    
    /** Clears the value of the 'cigar' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearCigar() {
      cigar = null;
      fieldSetFlags()[9] = false;
      return this;
    }

    /** Gets the value of the 'oldCigar' field */
    public java.lang.CharSequence getOldCigar() {
      return oldCigar;
    }
    
    /** Sets the value of the 'oldCigar' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setOldCigar(java.lang.CharSequence value) {
      validate(fields()[10], value);
      this.oldCigar = value;
      fieldSetFlags()[10] = true;
      return this; 
    }
    
    /** Checks whether the 'oldCigar' field has been set */
    public boolean hasOldCigar() {
      return fieldSetFlags()[10];
    }
    
    /** Clears the value of the 'oldCigar' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearOldCigar() {
      oldCigar = null;
      fieldSetFlags()[10] = false;
      return this;
    }

    /** Gets the value of the 'basesTrimmedFromStart' field */
    public java.lang.Integer getBasesTrimmedFromStart() {
      return basesTrimmedFromStart;
    }
    
    /** Sets the value of the 'basesTrimmedFromStart' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setBasesTrimmedFromStart(java.lang.Integer value) {
      validate(fields()[11], value);
      this.basesTrimmedFromStart = value;
      fieldSetFlags()[11] = true;
      return this; 
    }
    
    /** Checks whether the 'basesTrimmedFromStart' field has been set */
    public boolean hasBasesTrimmedFromStart() {
      return fieldSetFlags()[11];
    }
    
    /** Clears the value of the 'basesTrimmedFromStart' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearBasesTrimmedFromStart() {
      basesTrimmedFromStart = null;
      fieldSetFlags()[11] = false;
      return this;
    }

    /** Gets the value of the 'basesTrimmedFromEnd' field */
    public java.lang.Integer getBasesTrimmedFromEnd() {
      return basesTrimmedFromEnd;
    }
    
    /** Sets the value of the 'basesTrimmedFromEnd' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setBasesTrimmedFromEnd(java.lang.Integer value) {
      validate(fields()[12], value);
      this.basesTrimmedFromEnd = value;
      fieldSetFlags()[12] = true;
      return this; 
    }
    
    /** Checks whether the 'basesTrimmedFromEnd' field has been set */
    public boolean hasBasesTrimmedFromEnd() {
      return fieldSetFlags()[12];
    }
    
    /** Clears the value of the 'basesTrimmedFromEnd' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearBasesTrimmedFromEnd() {
      basesTrimmedFromEnd = null;
      fieldSetFlags()[12] = false;
      return this;
    }

    /** Gets the value of the 'readPaired' field */
    public java.lang.Boolean getReadPaired() {
      return readPaired;
    }
    
    /** Sets the value of the 'readPaired' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setReadPaired(java.lang.Boolean value) {
      validate(fields()[13], value);
      this.readPaired = value;
      fieldSetFlags()[13] = true;
      return this; 
    }
    
    /** Checks whether the 'readPaired' field has been set */
    public boolean hasReadPaired() {
      return fieldSetFlags()[13];
    }
    
    /** Clears the value of the 'readPaired' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearReadPaired() {
      readPaired = null;
      fieldSetFlags()[13] = false;
      return this;
    }

    /** Gets the value of the 'properPair' field */
    public java.lang.Boolean getProperPair() {
      return properPair;
    }
    
    /** Sets the value of the 'properPair' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setProperPair(java.lang.Boolean value) {
      validate(fields()[14], value);
      this.properPair = value;
      fieldSetFlags()[14] = true;
      return this; 
    }
    
    /** Checks whether the 'properPair' field has been set */
    public boolean hasProperPair() {
      return fieldSetFlags()[14];
    }
    
    /** Clears the value of the 'properPair' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearProperPair() {
      properPair = null;
      fieldSetFlags()[14] = false;
      return this;
    }

    /** Gets the value of the 'readMapped' field */
    public java.lang.Boolean getReadMapped() {
      return readMapped;
    }
    
    /** Sets the value of the 'readMapped' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setReadMapped(java.lang.Boolean value) {
      validate(fields()[15], value);
      this.readMapped = value;
      fieldSetFlags()[15] = true;
      return this; 
    }
    
    /** Checks whether the 'readMapped' field has been set */
    public boolean hasReadMapped() {
      return fieldSetFlags()[15];
    }
    
    /** Clears the value of the 'readMapped' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearReadMapped() {
      readMapped = null;
      fieldSetFlags()[15] = false;
      return this;
    }

    /** Gets the value of the 'mateMapped' field */
    public java.lang.Boolean getMateMapped() {
      return mateMapped;
    }
    
    /** Sets the value of the 'mateMapped' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMateMapped(java.lang.Boolean value) {
      validate(fields()[16], value);
      this.mateMapped = value;
      fieldSetFlags()[16] = true;
      return this; 
    }
    
    /** Checks whether the 'mateMapped' field has been set */
    public boolean hasMateMapped() {
      return fieldSetFlags()[16];
    }
    
    /** Clears the value of the 'mateMapped' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMateMapped() {
      mateMapped = null;
      fieldSetFlags()[16] = false;
      return this;
    }

    /** Gets the value of the 'firstOfPair' field */
    public java.lang.Boolean getFirstOfPair() {
      return firstOfPair;
    }
    
    /** Sets the value of the 'firstOfPair' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setFirstOfPair(java.lang.Boolean value) {
      validate(fields()[17], value);
      this.firstOfPair = value;
      fieldSetFlags()[17] = true;
      return this; 
    }
    
    /** Checks whether the 'firstOfPair' field has been set */
    public boolean hasFirstOfPair() {
      return fieldSetFlags()[17];
    }
    
    /** Clears the value of the 'firstOfPair' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearFirstOfPair() {
      firstOfPair = null;
      fieldSetFlags()[17] = false;
      return this;
    }

    /** Gets the value of the 'secondOfPair' field */
    public java.lang.Boolean getSecondOfPair() {
      return secondOfPair;
    }
    
    /** Sets the value of the 'secondOfPair' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setSecondOfPair(java.lang.Boolean value) {
      validate(fields()[18], value);
      this.secondOfPair = value;
      fieldSetFlags()[18] = true;
      return this; 
    }
    
    /** Checks whether the 'secondOfPair' field has been set */
    public boolean hasSecondOfPair() {
      return fieldSetFlags()[18];
    }
    
    /** Clears the value of the 'secondOfPair' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearSecondOfPair() {
      secondOfPair = null;
      fieldSetFlags()[18] = false;
      return this;
    }

    /** Gets the value of the 'failedVendorQualityChecks' field */
    public java.lang.Boolean getFailedVendorQualityChecks() {
      return failedVendorQualityChecks;
    }
    
    /** Sets the value of the 'failedVendorQualityChecks' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setFailedVendorQualityChecks(java.lang.Boolean value) {
      validate(fields()[19], value);
      this.failedVendorQualityChecks = value;
      fieldSetFlags()[19] = true;
      return this; 
    }
    
    /** Checks whether the 'failedVendorQualityChecks' field has been set */
    public boolean hasFailedVendorQualityChecks() {
      return fieldSetFlags()[19];
    }
    
    /** Clears the value of the 'failedVendorQualityChecks' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearFailedVendorQualityChecks() {
      failedVendorQualityChecks = null;
      fieldSetFlags()[19] = false;
      return this;
    }

    /** Gets the value of the 'duplicateRead' field */
    public java.lang.Boolean getDuplicateRead() {
      return duplicateRead;
    }
    
    /** Sets the value of the 'duplicateRead' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setDuplicateRead(java.lang.Boolean value) {
      validate(fields()[20], value);
      this.duplicateRead = value;
      fieldSetFlags()[20] = true;
      return this; 
    }
    
    /** Checks whether the 'duplicateRead' field has been set */
    public boolean hasDuplicateRead() {
      return fieldSetFlags()[20];
    }
    
    /** Clears the value of the 'duplicateRead' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearDuplicateRead() {
      duplicateRead = null;
      fieldSetFlags()[20] = false;
      return this;
    }

    /** Gets the value of the 'readNegativeStrand' field */
    public java.lang.Boolean getReadNegativeStrand() {
      return readNegativeStrand;
    }
    
    /** Sets the value of the 'readNegativeStrand' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setReadNegativeStrand(java.lang.Boolean value) {
      validate(fields()[21], value);
      this.readNegativeStrand = value;
      fieldSetFlags()[21] = true;
      return this; 
    }
    
    /** Checks whether the 'readNegativeStrand' field has been set */
    public boolean hasReadNegativeStrand() {
      return fieldSetFlags()[21];
    }
    
    /** Clears the value of the 'readNegativeStrand' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearReadNegativeStrand() {
      readNegativeStrand = null;
      fieldSetFlags()[21] = false;
      return this;
    }

    /** Gets the value of the 'mateNegativeStrand' field */
    public java.lang.Boolean getMateNegativeStrand() {
      return mateNegativeStrand;
    }
    
    /** Sets the value of the 'mateNegativeStrand' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMateNegativeStrand(java.lang.Boolean value) {
      validate(fields()[22], value);
      this.mateNegativeStrand = value;
      fieldSetFlags()[22] = true;
      return this; 
    }
    
    /** Checks whether the 'mateNegativeStrand' field has been set */
    public boolean hasMateNegativeStrand() {
      return fieldSetFlags()[22];
    }
    
    /** Clears the value of the 'mateNegativeStrand' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMateNegativeStrand() {
      mateNegativeStrand = null;
      fieldSetFlags()[22] = false;
      return this;
    }

    /** Gets the value of the 'primaryAlignment' field */
    public java.lang.Boolean getPrimaryAlignment() {
      return primaryAlignment;
    }
    
    /** Sets the value of the 'primaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setPrimaryAlignment(java.lang.Boolean value) {
      validate(fields()[23], value);
      this.primaryAlignment = value;
      fieldSetFlags()[23] = true;
      return this; 
    }
    
    /** Checks whether the 'primaryAlignment' field has been set */
    public boolean hasPrimaryAlignment() {
      return fieldSetFlags()[23];
    }
    
    /** Clears the value of the 'primaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearPrimaryAlignment() {
      primaryAlignment = null;
      fieldSetFlags()[23] = false;
      return this;
    }

    /** Gets the value of the 'secondaryAlignment' field */
    public java.lang.Boolean getSecondaryAlignment() {
      return secondaryAlignment;
    }
    
    /** Sets the value of the 'secondaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setSecondaryAlignment(java.lang.Boolean value) {
      validate(fields()[24], value);
      this.secondaryAlignment = value;
      fieldSetFlags()[24] = true;
      return this; 
    }
    
    /** Checks whether the 'secondaryAlignment' field has been set */
    public boolean hasSecondaryAlignment() {
      return fieldSetFlags()[24];
    }
    
    /** Clears the value of the 'secondaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearSecondaryAlignment() {
      secondaryAlignment = null;
      fieldSetFlags()[24] = false;
      return this;
    }

    /** Gets the value of the 'supplementaryAlignment' field */
    public java.lang.Boolean getSupplementaryAlignment() {
      return supplementaryAlignment;
    }
    
    /** Sets the value of the 'supplementaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setSupplementaryAlignment(java.lang.Boolean value) {
      validate(fields()[25], value);
      this.supplementaryAlignment = value;
      fieldSetFlags()[25] = true;
      return this; 
    }
    
    /** Checks whether the 'supplementaryAlignment' field has been set */
    public boolean hasSupplementaryAlignment() {
      return fieldSetFlags()[25];
    }
    
    /** Clears the value of the 'supplementaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearSupplementaryAlignment() {
      supplementaryAlignment = null;
      fieldSetFlags()[25] = false;
      return this;
    }

    /** Gets the value of the 'mismatchingPositions' field */
    public java.lang.CharSequence getMismatchingPositions() {
      return mismatchingPositions;
    }
    
    /** Sets the value of the 'mismatchingPositions' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMismatchingPositions(java.lang.CharSequence value) {
      validate(fields()[26], value);
      this.mismatchingPositions = value;
      fieldSetFlags()[26] = true;
      return this; 
    }
    
    /** Checks whether the 'mismatchingPositions' field has been set */
    public boolean hasMismatchingPositions() {
      return fieldSetFlags()[26];
    }
    
    /** Clears the value of the 'mismatchingPositions' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMismatchingPositions() {
      mismatchingPositions = null;
      fieldSetFlags()[26] = false;
      return this;
    }

    /** Gets the value of the 'origQual' field */
    public java.lang.CharSequence getOrigQual() {
      return origQual;
    }
    
    /** Sets the value of the 'origQual' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setOrigQual(java.lang.CharSequence value) {
      validate(fields()[27], value);
      this.origQual = value;
      fieldSetFlags()[27] = true;
      return this; 
    }
    
    /** Checks whether the 'origQual' field has been set */
    public boolean hasOrigQual() {
      return fieldSetFlags()[27];
    }
    
    /** Clears the value of the 'origQual' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearOrigQual() {
      origQual = null;
      fieldSetFlags()[27] = false;
      return this;
    }

    /** Gets the value of the 'attributes' field */
    public java.lang.CharSequence getAttributes() {
      return attributes;
    }
    
    /** Sets the value of the 'attributes' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setAttributes(java.lang.CharSequence value) {
      validate(fields()[28], value);
      this.attributes = value;
      fieldSetFlags()[28] = true;
      return this; 
    }
    
    /** Checks whether the 'attributes' field has been set */
    public boolean hasAttributes() {
      return fieldSetFlags()[28];
    }
    
    /** Clears the value of the 'attributes' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearAttributes() {
      attributes = null;
      fieldSetFlags()[28] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupName' field */
    public java.lang.CharSequence getRecordGroupName() {
      return recordGroupName;
    }
    
    /** Sets the value of the 'recordGroupName' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupName(java.lang.CharSequence value) {
      validate(fields()[29], value);
      this.recordGroupName = value;
      fieldSetFlags()[29] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupName' field has been set */
    public boolean hasRecordGroupName() {
      return fieldSetFlags()[29];
    }
    
    /** Clears the value of the 'recordGroupName' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupName() {
      recordGroupName = null;
      fieldSetFlags()[29] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupSequencingCenter' field */
    public java.lang.CharSequence getRecordGroupSequencingCenter() {
      return recordGroupSequencingCenter;
    }
    
    /** Sets the value of the 'recordGroupSequencingCenter' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupSequencingCenter(java.lang.CharSequence value) {
      validate(fields()[30], value);
      this.recordGroupSequencingCenter = value;
      fieldSetFlags()[30] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupSequencingCenter' field has been set */
    public boolean hasRecordGroupSequencingCenter() {
      return fieldSetFlags()[30];
    }
    
    /** Clears the value of the 'recordGroupSequencingCenter' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupSequencingCenter() {
      recordGroupSequencingCenter = null;
      fieldSetFlags()[30] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupDescription' field */
    public java.lang.CharSequence getRecordGroupDescription() {
      return recordGroupDescription;
    }
    
    /** Sets the value of the 'recordGroupDescription' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupDescription(java.lang.CharSequence value) {
      validate(fields()[31], value);
      this.recordGroupDescription = value;
      fieldSetFlags()[31] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupDescription' field has been set */
    public boolean hasRecordGroupDescription() {
      return fieldSetFlags()[31];
    }
    
    /** Clears the value of the 'recordGroupDescription' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupDescription() {
      recordGroupDescription = null;
      fieldSetFlags()[31] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupRunDateEpoch' field */
    public java.lang.Long getRecordGroupRunDateEpoch() {
      return recordGroupRunDateEpoch;
    }
    
    /** Sets the value of the 'recordGroupRunDateEpoch' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupRunDateEpoch(java.lang.Long value) {
      validate(fields()[32], value);
      this.recordGroupRunDateEpoch = value;
      fieldSetFlags()[32] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupRunDateEpoch' field has been set */
    public boolean hasRecordGroupRunDateEpoch() {
      return fieldSetFlags()[32];
    }
    
    /** Clears the value of the 'recordGroupRunDateEpoch' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupRunDateEpoch() {
      recordGroupRunDateEpoch = null;
      fieldSetFlags()[32] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupFlowOrder' field */
    public java.lang.CharSequence getRecordGroupFlowOrder() {
      return recordGroupFlowOrder;
    }
    
    /** Sets the value of the 'recordGroupFlowOrder' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupFlowOrder(java.lang.CharSequence value) {
      validate(fields()[33], value);
      this.recordGroupFlowOrder = value;
      fieldSetFlags()[33] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupFlowOrder' field has been set */
    public boolean hasRecordGroupFlowOrder() {
      return fieldSetFlags()[33];
    }
    
    /** Clears the value of the 'recordGroupFlowOrder' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupFlowOrder() {
      recordGroupFlowOrder = null;
      fieldSetFlags()[33] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupKeySequence' field */
    public java.lang.CharSequence getRecordGroupKeySequence() {
      return recordGroupKeySequence;
    }
    
    /** Sets the value of the 'recordGroupKeySequence' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupKeySequence(java.lang.CharSequence value) {
      validate(fields()[34], value);
      this.recordGroupKeySequence = value;
      fieldSetFlags()[34] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupKeySequence' field has been set */
    public boolean hasRecordGroupKeySequence() {
      return fieldSetFlags()[34];
    }
    
    /** Clears the value of the 'recordGroupKeySequence' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupKeySequence() {
      recordGroupKeySequence = null;
      fieldSetFlags()[34] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupLibrary' field */
    public java.lang.CharSequence getRecordGroupLibrary() {
      return recordGroupLibrary;
    }
    
    /** Sets the value of the 'recordGroupLibrary' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupLibrary(java.lang.CharSequence value) {
      validate(fields()[35], value);
      this.recordGroupLibrary = value;
      fieldSetFlags()[35] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupLibrary' field has been set */
    public boolean hasRecordGroupLibrary() {
      return fieldSetFlags()[35];
    }
    
    /** Clears the value of the 'recordGroupLibrary' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupLibrary() {
      recordGroupLibrary = null;
      fieldSetFlags()[35] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupPredictedMedianInsertSize' field */
    public java.lang.Integer getRecordGroupPredictedMedianInsertSize() {
      return recordGroupPredictedMedianInsertSize;
    }
    
    /** Sets the value of the 'recordGroupPredictedMedianInsertSize' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupPredictedMedianInsertSize(java.lang.Integer value) {
      validate(fields()[36], value);
      this.recordGroupPredictedMedianInsertSize = value;
      fieldSetFlags()[36] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupPredictedMedianInsertSize' field has been set */
    public boolean hasRecordGroupPredictedMedianInsertSize() {
      return fieldSetFlags()[36];
    }
    
    /** Clears the value of the 'recordGroupPredictedMedianInsertSize' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupPredictedMedianInsertSize() {
      recordGroupPredictedMedianInsertSize = null;
      fieldSetFlags()[36] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupPlatform' field */
    public java.lang.CharSequence getRecordGroupPlatform() {
      return recordGroupPlatform;
    }
    
    /** Sets the value of the 'recordGroupPlatform' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupPlatform(java.lang.CharSequence value) {
      validate(fields()[37], value);
      this.recordGroupPlatform = value;
      fieldSetFlags()[37] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupPlatform' field has been set */
    public boolean hasRecordGroupPlatform() {
      return fieldSetFlags()[37];
    }
    
    /** Clears the value of the 'recordGroupPlatform' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupPlatform() {
      recordGroupPlatform = null;
      fieldSetFlags()[37] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupPlatformUnit' field */
    public java.lang.CharSequence getRecordGroupPlatformUnit() {
      return recordGroupPlatformUnit;
    }
    
    /** Sets the value of the 'recordGroupPlatformUnit' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupPlatformUnit(java.lang.CharSequence value) {
      validate(fields()[38], value);
      this.recordGroupPlatformUnit = value;
      fieldSetFlags()[38] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupPlatformUnit' field has been set */
    public boolean hasRecordGroupPlatformUnit() {
      return fieldSetFlags()[38];
    }
    
    /** Clears the value of the 'recordGroupPlatformUnit' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupPlatformUnit() {
      recordGroupPlatformUnit = null;
      fieldSetFlags()[38] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupSample' field */
    public java.lang.CharSequence getRecordGroupSample() {
      return recordGroupSample;
    }
    
    /** Sets the value of the 'recordGroupSample' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupSample(java.lang.CharSequence value) {
      validate(fields()[39], value);
      this.recordGroupSample = value;
      fieldSetFlags()[39] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupSample' field has been set */
    public boolean hasRecordGroupSample() {
      return fieldSetFlags()[39];
    }
    
    /** Clears the value of the 'recordGroupSample' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupSample() {
      recordGroupSample = null;
      fieldSetFlags()[39] = false;
      return this;
    }

    /** Gets the value of the 'mateAlignmentStart' field */
    public java.lang.Long getMateAlignmentStart() {
      return mateAlignmentStart;
    }
    
    /** Sets the value of the 'mateAlignmentStart' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMateAlignmentStart(java.lang.Long value) {
      validate(fields()[40], value);
      this.mateAlignmentStart = value;
      fieldSetFlags()[40] = true;
      return this; 
    }
    
    /** Checks whether the 'mateAlignmentStart' field has been set */
    public boolean hasMateAlignmentStart() {
      return fieldSetFlags()[40];
    }
    
    /** Clears the value of the 'mateAlignmentStart' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMateAlignmentStart() {
      mateAlignmentStart = null;
      fieldSetFlags()[40] = false;
      return this;
    }

    /** Gets the value of the 'mateAlignmentEnd' field */
    public java.lang.Long getMateAlignmentEnd() {
      return mateAlignmentEnd;
    }
    
    /** Sets the value of the 'mateAlignmentEnd' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMateAlignmentEnd(java.lang.Long value) {
      validate(fields()[41], value);
      this.mateAlignmentEnd = value;
      fieldSetFlags()[41] = true;
      return this; 
    }
    
    /** Checks whether the 'mateAlignmentEnd' field has been set */
    public boolean hasMateAlignmentEnd() {
      return fieldSetFlags()[41];
    }
    
    /** Clears the value of the 'mateAlignmentEnd' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMateAlignmentEnd() {
      mateAlignmentEnd = null;
      fieldSetFlags()[41] = false;
      return this;
    }

    /** Gets the value of the 'mateContig' field */
    public org.bdgenomics.formats.avro.Contig getMateContig() {
      return mateContig;
    }
    
    /** Sets the value of the 'mateContig' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMateContig(org.bdgenomics.formats.avro.Contig value) {
      validate(fields()[42], value);
      this.mateContig = value;
      fieldSetFlags()[42] = true;
      return this; 
    }
    
    /** Checks whether the 'mateContig' field has been set */
    public boolean hasMateContig() {
      return fieldSetFlags()[42];
    }
    
    /** Clears the value of the 'mateContig' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMateContig() {
      mateContig = null;
      fieldSetFlags()[42] = false;
      return this;
    }

    @Override
    public AlignmentRecord build() {
      try {
        AlignmentRecord record = new AlignmentRecord();
        record.readNum = fieldSetFlags()[0] ? this.readNum : (java.lang.Integer) defaultValue(fields()[0]);
        record.contig = fieldSetFlags()[1] ? this.contig : (org.bdgenomics.formats.avro.Contig) defaultValue(fields()[1]);
        record.start = fieldSetFlags()[2] ? this.start : (java.lang.Long) defaultValue(fields()[2]);
        record.oldPosition = fieldSetFlags()[3] ? this.oldPosition : (java.lang.Long) defaultValue(fields()[3]);
        record.end = fieldSetFlags()[4] ? this.end : (java.lang.Long) defaultValue(fields()[4]);
        record.mapq = fieldSetFlags()[5] ? this.mapq : (java.lang.Integer) defaultValue(fields()[5]);
        record.readName = fieldSetFlags()[6] ? this.readName : (java.lang.CharSequence) defaultValue(fields()[6]);
        record.sequence = fieldSetFlags()[7] ? this.sequence : (java.lang.CharSequence) defaultValue(fields()[7]);
        record.qual = fieldSetFlags()[8] ? this.qual : (java.lang.CharSequence) defaultValue(fields()[8]);
        record.cigar = fieldSetFlags()[9] ? this.cigar : (java.lang.CharSequence) defaultValue(fields()[9]);
        record.oldCigar = fieldSetFlags()[10] ? this.oldCigar : (java.lang.CharSequence) defaultValue(fields()[10]);
        record.basesTrimmedFromStart = fieldSetFlags()[11] ? this.basesTrimmedFromStart : (java.lang.Integer) defaultValue(fields()[11]);
        record.basesTrimmedFromEnd = fieldSetFlags()[12] ? this.basesTrimmedFromEnd : (java.lang.Integer) defaultValue(fields()[12]);
        record.readPaired = fieldSetFlags()[13] ? this.readPaired : (java.lang.Boolean) defaultValue(fields()[13]);
        record.properPair = fieldSetFlags()[14] ? this.properPair : (java.lang.Boolean) defaultValue(fields()[14]);
        record.readMapped = fieldSetFlags()[15] ? this.readMapped : (java.lang.Boolean) defaultValue(fields()[15]);
        record.mateMapped = fieldSetFlags()[16] ? this.mateMapped : (java.lang.Boolean) defaultValue(fields()[16]);
        record.firstOfPair = fieldSetFlags()[17] ? this.firstOfPair : (java.lang.Boolean) defaultValue(fields()[17]);
        record.secondOfPair = fieldSetFlags()[18] ? this.secondOfPair : (java.lang.Boolean) defaultValue(fields()[18]);
        record.failedVendorQualityChecks = fieldSetFlags()[19] ? this.failedVendorQualityChecks : (java.lang.Boolean) defaultValue(fields()[19]);
        record.duplicateRead = fieldSetFlags()[20] ? this.duplicateRead : (java.lang.Boolean) defaultValue(fields()[20]);
        record.readNegativeStrand = fieldSetFlags()[21] ? this.readNegativeStrand : (java.lang.Boolean) defaultValue(fields()[21]);
        record.mateNegativeStrand = fieldSetFlags()[22] ? this.mateNegativeStrand : (java.lang.Boolean) defaultValue(fields()[22]);
        record.primaryAlignment = fieldSetFlags()[23] ? this.primaryAlignment : (java.lang.Boolean) defaultValue(fields()[23]);
        record.secondaryAlignment = fieldSetFlags()[24] ? this.secondaryAlignment : (java.lang.Boolean) defaultValue(fields()[24]);
        record.supplementaryAlignment = fieldSetFlags()[25] ? this.supplementaryAlignment : (java.lang.Boolean) defaultValue(fields()[25]);
        record.mismatchingPositions = fieldSetFlags()[26] ? this.mismatchingPositions : (java.lang.CharSequence) defaultValue(fields()[26]);
        record.origQual = fieldSetFlags()[27] ? this.origQual : (java.lang.CharSequence) defaultValue(fields()[27]);
        record.attributes = fieldSetFlags()[28] ? this.attributes : (java.lang.CharSequence) defaultValue(fields()[28]);
        record.recordGroupName = fieldSetFlags()[29] ? this.recordGroupName : (java.lang.CharSequence) defaultValue(fields()[29]);
        record.recordGroupSequencingCenter = fieldSetFlags()[30] ? this.recordGroupSequencingCenter : (java.lang.CharSequence) defaultValue(fields()[30]);
        record.recordGroupDescription = fieldSetFlags()[31] ? this.recordGroupDescription : (java.lang.CharSequence) defaultValue(fields()[31]);
        record.recordGroupRunDateEpoch = fieldSetFlags()[32] ? this.recordGroupRunDateEpoch : (java.lang.Long) defaultValue(fields()[32]);
        record.recordGroupFlowOrder = fieldSetFlags()[33] ? this.recordGroupFlowOrder : (java.lang.CharSequence) defaultValue(fields()[33]);
        record.recordGroupKeySequence = fieldSetFlags()[34] ? this.recordGroupKeySequence : (java.lang.CharSequence) defaultValue(fields()[34]);
        record.recordGroupLibrary = fieldSetFlags()[35] ? this.recordGroupLibrary : (java.lang.CharSequence) defaultValue(fields()[35]);
        record.recordGroupPredictedMedianInsertSize = fieldSetFlags()[36] ? this.recordGroupPredictedMedianInsertSize : (java.lang.Integer) defaultValue(fields()[36]);
        record.recordGroupPlatform = fieldSetFlags()[37] ? this.recordGroupPlatform : (java.lang.CharSequence) defaultValue(fields()[37]);
        record.recordGroupPlatformUnit = fieldSetFlags()[38] ? this.recordGroupPlatformUnit : (java.lang.CharSequence) defaultValue(fields()[38]);
        record.recordGroupSample = fieldSetFlags()[39] ? this.recordGroupSample : (java.lang.CharSequence) defaultValue(fields()[39]);
        record.mateAlignmentStart = fieldSetFlags()[40] ? this.mateAlignmentStart : (java.lang.Long) defaultValue(fields()[40]);
        record.mateAlignmentEnd = fieldSetFlags()[41] ? this.mateAlignmentEnd : (java.lang.Long) defaultValue(fields()[41]);
        record.mateContig = fieldSetFlags()[42] ? this.mateContig : (org.bdgenomics.formats.avro.Contig) defaultValue(fields()[42]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
